# 1. Наследование и расширяемость систем. Проблемы наследования»
## Инструкция к выполнению домашнего задания
### Перед тем как отправить своё решение на проверку преподавателю, сверьтесь с чеклистом.

1. В решении выполнены все требования задания
2. Правильно настроен Maven-проект, тесты проходят
3. Что делать, если возникли сложности
4. Отформатирован код
5. Настроен Github CI с verify-сборкой Maven и JaCoCo в режиме генерации отчётов с покрытием на 100% по бранчам методов с логикой
Задание 1. Менеджер товаров (обязательное к выполнению)
Вам необходимо реализовать менеджер товаров, который умеет:

1.добавлять товары в репозиторий,

2.искать товары.

Что нужно сделать:

Разработайте базовый класс Product, содержащий ID, название, стоимость.
Разработайте два унаследованных от Product класса: Book с текстовыми полями «название» и «автор» и Smartphone с текстовыми полями «название» и «производитель»; общие поля вынесите в родителя.
Разработайте репозиторий, позволяющий сохранять Product, получать все сохранённые Product и удалять по ID. Для этого репозиторий будет хранить у себя поле с типом Product[] (массив товаров).
Разработайте менеджера, который умеет добавлять Product в репозиторий и осуществлять поиск по ним. Для этого вам нужно создать класс, конструктор которого будет принимать параметром репозиторий, а также с методом publiс void add(Product product) и методом поиска (см. ниже).
Как осуществлять поиск
У менеджера должен быть метод searchBy(String text), который возвращает массив найденных товаров.

public class ProductManager {

  // добавьте необходимые поля, конструкторы и методы

  public Product[] searchBy(String text) {
  
    Product[] result = new Product[0]; // тут будем хранить подошедшие запросу продукты
    
    for (Product product: repository.findAll()) {
    
      if (matches(product, text)) {
      
        // "добавляем в конец" массива result продукт product
        
      }
      
    }
    
    return result;
  }

  // метод определения соответствия товара product запросу search
  public boolean matches(Product product, String search) {
    if (product.getName().contains(search)) {
      return true;
    } else {
      return false;
    }
    // или в одну строку:
    // return product.getName().contains(search);
  }
}
Менеджер при переборе всех продуктов, хранящихся в репозитории, должен для каждого продукта вызывать определённый в классе менеджера же метод matches, который проверяет, соответствует ли продукт поисковому запросу.

При проверке на соответствие запросу товара мы проверяем вхождение запроса в текст названия товара.

Напишите тесты на менеджер и репозиторий, добившись 100% покрытия по бранчам методов с логикой.

#### Итого: отправьте на проверку ссылку на репозиторий GitHub с вашим проектом.

# 2.NotFoundException (обязательное к выполнению)

Вы развиваете приложение с менеджером товаров, который мы рассматривали на лекции, и решили сделать так, чтобы при попытке удаления несуществующего объекта из репозитория генерировалось ваше исключение, а не ArrayIndexOfBoundsException.

Обратите внимание: это правильный подход, поскольку таким образом вы сообщаете через генерацию исключения, что это исключение, вписывающееся в вашу логику, а не ошибка программиста.

### Что нужно сделать:

    Возьмите проект с менеджером, репозиторием и товарами, мы его писали в рамках ДЗ про наследование.
    Создайте класс исключения NotFoundException, отнаследовавшись от RuntimeException, и реализуйте как минимум конструктор с параметром-сообщением. Он будет просто вызывать суперконструктор предка, см. подсказку.
    В методе удаления removeById сначала проверяйте, есть ли элемент. Для этого прямо из метода removeById вызывайте метод findById: если результат null, тогда выкидывайте исключение NotFoundException.
    Напишите два автотеста на репозиторий: первый должен проверять успешность удаления существующего элемента, второй — генерации NotFoundException при попытке удаления несуществующего элемента.

#### Подсказка
Конструктор вашего исключения должен выглядеть как-то так:

Для реализации этой логики вам понадобится добавить метод findById, предназначенный для поиска товара в репозитории по его ID. Так, он должен принимать параметр ID искомого товара, пробегаться по всем товарам репозитория и сверять их ID с искомым, в случае совпадения делать return этого товара. Если же, пробежав все товары репозитория, ни один подходящий найден не был, то есть цикл закончился без вызова return внутри него, то следует сделать return null. Общая схема этого метода будет такой:

public Product findById(???) {
  for (???) {
    if (???) {
      return product;
    }
  }
  return null;
}

Убедитесь, что ваши автотесты проходят. Напоминаем, что проект должен быть на базе Maven, с подключёнными зависимостями и необходимыми плагинами.

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код и автотесты к нему.

Мы рекомендуем вам указывать в сообщении исключения: при удалении по какому конкретно ID было сгенерировано ваше исключение. Простейший способ, как это можно сделать: "Element with id: " + id + " not found".

#### Итого: отправьте на проверку ссылку на репозиторий GitHub с вашим проектом.
